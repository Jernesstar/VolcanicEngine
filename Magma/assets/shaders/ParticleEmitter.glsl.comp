#version 450 core

struct Particle {
    vec3 Position;
    vec3 Velocity;
    float Life;
};

layout(std430, binding = 0) writeonly restrict buffer SSBO_0 {
    Particle Particles[];
};

layout(std430, binding = 1) coherent restrict buffer SSBO_1 {
    coherent int Count;
    int Indices[];
} FreeList;

struct EmitterSettings {
    vec3 Position;
    float ParticleLifetime;
};
// Used as initial seed to the PRNG.
uint pcg_hash(uint seed)
{
    uint state = seed * 747796405u + 2891336453u;
    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    return (word >> 22u) ^ word;
}

// Used to advance the PCG state.
uint rand_pcg(inout uint rng_state)
{
    uint state = rng_state;
    rng_state = rng_state * 747796405u + 2891336453u;
    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    return (word >> 22u) ^ word;
}

// Advances the prng state and returns the corresponding random float.
float rand(inout uint state)
{
    uint x = rand_pcg(state);
    state = x;
    return float(x) * uintBitsToFloat(0x2f800000u);
}

uniform int u_ParticlesToSpawn;
uniform EmitterSettings u_Emitter;

void MakeParticle(out Particle particle) {
    particle.Life = u_Emitter.ParticleLifetime;
    particle.Velocity = vec3(0.001f);
    particle.Position = u_Emitter.Position;
}

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;
void main() {
    uint index = gl_GlobalInvocationID.x;
    if(index >= u_ParticlesToSpawn)
        return;

    // Undo decrement and return if nothing in freelist
    int freeListIndex = atomicAdd(FreeList.Count, -1) - 1;
    if(freeListIndex < 0) {
        atomicAdd(FreeList.Count, 1);
        return;
    }

    int particleIndex = FreeList.Indices[freeListIndex];
    MakeParticle(Particles[particleIndex]);
}